<blockquote>
<p>高性能 Webapp 解决方案，利用后端渲染方式，实现传统 webapp 前端局刷效果，实现一站式的体验效果，大幅提高性能和静态资源缓存命中率。</p>
</blockquote>
<h3 class="" id="介绍"><a name="%E4%BB%8B%E7%BB%8D" class="anchor" href="#%E4%BB%8B%E7%BB%8D"><span class="octicon octicon-link"></span></a>介绍</h3><p>高性能 Webapp 解决方案，与传统 webapp 前端局刷（backbone 等）相比，优势有：</p>
<ul>
<li>采用后端渲染，不使用前端模板，大幅提高渲染性能</li>
<li>几乎不改变开发习惯，轻松上手和改造原有项目。</li>
</ul>
<h3 class="" id="快速上手"><a name="%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B" class="anchor" href="#%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B"><span class="octicon octicon-link"></span></a>快速上手</h3><p>第一步，需要安装 <a href="https://github.com/xiangshouding/bigpipe.smarty" title="BigPipe.smarty">fis-plus</a></p>
<blockquote>
<p>$ npm install -g fis-plus</p>
</blockquote>
<p>第二步，下载示例代码</p>
<p>linux or Unix:</p>
<blockquote>
<p>$ wget <a href="https://github.com/xiangshouding/bigpipe.smarty/archive/master.zip">https://github.com/xiangshouding/bigpipe.smarty/archive/master.zip</a></p>
</blockquote>
<p>windows:</p>
<p><a href="https://github.com/xiangshouding/bigpipe.smarty/archive/master.zip"> 下载 </a></p>
<p>后解压，进入目录 single</p>
<blockquote>
<p>$ cd bigpipe.smarty-master/single</p>
</blockquote>
<p>第三步，使用安装的 <a href="https://github.com/xiangshouding/bigpipe.smarty" title="BigPipe.smarty">fis-plus</a> 编译发布项目</p>
<blockquote>
<p>$ fisp release -cmpr common</p>
<p>$ fisp release -cmpr index</p>
</blockquote>
<p>第四步，启动开发服务器</p>
<blockquote>
<p>$ fisp server start</p>
</blockquote>
<p>第五步，安装本地测试框架</p>
<blockquote>
<p>$ fisp server install pc</p>
</blockquote>
<p>第六步，打开浏览器访问</p>
<p>局部刷新: <a href="">http://127.0.0.1:8080/index/page/index</a></p>
<h3 class="" id="使用文档"><a name="%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3" class="anchor" href="#%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3"><span class="octicon octicon-link"></span></a>使用文档</h3><h4 class=""><a name="%3Cstrong%3E%E5%BC%95%E5%85%A5%E6%8F%92%E4%BB%B6%3C/strong%3E" class="anchor" href="#%3Cstrong%3E%E5%BC%95%E5%85%A5%E6%8F%92%E4%BB%B6%3C/strong%3E"><span class="octicon octicon-link"></span></a><strong>引入插件</strong></h4><p>Webapp 插件主要包括：</p>
<ul>
<li>后端解决方案插件 <a href="https://github.com/xiangshouding/fis-smarty-bigpipe-plugin" title="quickling plugin">Webapp解决方案的插件</a>。下载后放置到项目的plugin目录中。</li>
<li>前端加载器<a href="https://github.com/xiangshouding/bigpipe.smarty/blob/master/lazyrender/static/BigPipe.js" title="loader">loader</a>，<a href="https://github.com/xiangshouding/bigpipe.smarty/blob/master/lazyrender/static/BigPipe.js" title="loader">前端loader</a>依赖<a href="https://github.com/xiangshouding/bigpipe.smarty/blob/master/lazyrender/static/lazyload.js" title="lazyload.js">lazyload.js</a></li>
<li>FIS组件化库<a href="https://github.com/zjcqoo/mod" title="modjs">modjs</a>保持最新</li>
</ul>
<p>插件引入代码如下：</p>
<pre><code class="hljs lang-smarty">{%html framework=<span class="hljs-string">"common:static/lib/js/mod.js"</span>%}
    {%head%}
        <span class="hljs-keyword">...</span>
        {%<span class="hljs-keyword">require</span> name=<span class="hljs-string">"common:static/lib/js/lazyload.js"</span>%}
        {%<span class="hljs-keyword">require</span> name=<span class="hljs-string">"common:static/lib/js/BigPipe.js"</span>%}
        <span class="hljs-keyword">...</span>
    {%/head%}
    {%body%}
        <span class="hljs-keyword">...</span>
    {%/body%}
{%/html%}
</code></pre>
<p>最后，发布这个项目；访问对应 URL 查看页面。</p>
<h4 class=""><a name="%3Cstrong%3E%E6%94%AF%E6%8C%81localstorage%3C/strong%3E" class="anchor" href="#%3Cstrong%3E%E6%94%AF%E6%8C%81localstorage%3C/strong%3E"><span class="octicon octicon-link"></span></a><strong>支持localstorage</strong></h4><blockquote>
<p>无线端使用 localstorage 本地缓存，可以减少请求数目，提高性能。高性能 Webapp 解决方案也内置了 localstorage 本地缓存方案。</p>
</blockquote>
<p>只需要引入支持 localstorage 的 FIS 组件化库 <a href="https://github.com/xiangshouding/mod-store.js" title="mod-store.js">mod-store.js</a> 即可。</p>
<p>插件引入代码如下：</p>
<pre><code class="hljs lang-smarty">{%html framework=<span class="hljs-string">"common:static/lib/js/mod-store.js"</span>%}
    {%head%}
        <span class="hljs-keyword">...</span>
        {%<span class="hljs-keyword">require</span> name=<span class="hljs-string">"common:static/lib/js/lazyload.js"</span>%}
        {%<span class="hljs-keyword">require</span> name=<span class="hljs-string">"common:static/lib/js/BigPipe.js"</span>%}
        <span class="hljs-keyword">...</span>
    {%/head%}
    {%body%}
        <span class="hljs-keyword">...</span>
    {%/body%}
{%/html%}
</code></pre>
<h4 class=""><a name="%3Cstrong%3E%E5%89%8D%E7%AB%AFloader%3C/strong%3E" class="anchor" href="#%3Cstrong%3E%E5%89%8D%E7%AB%AFloader%3C/strong%3E"><span class="octicon octicon-link"></span></a><strong>前端loader</strong></h4><p><code>局部刷新 </code> 中 FIS 提供了一个可被异步请求的<code> 后端框架 </code>(以<a href="https://github.com/xiangshouding/bigpipe.smarty" title="BigPipe.smarty">smarty 插件</a> 的方式)；
<a href="https://github.com/xiangshouding/bigpipe.smarty/blob/master/single/common/static/lib/js/BigPipe.js" title="loader">前端 loader</a>。</p>
<p>前端 loader 提供接口 <code>fetch</code> 方法，来异步请求渲染一个 widget。</p>
<pre><code class="hljs lang-javascript">BigPipe.fetch<span class="hljs-comment">(url, containerId)</span>;
</code></pre>
<p>例子</p>
<pre><code class="hljs lang-javascript"><span class="hljs-transposed_variable">BigPipe.</span>fetch(<span class="hljs-string">'/index/page/index?pagelets[]="</span>pager<span class="hljs-string">"'</span>, <span class="hljs-string">'pager'</span>);
</code></pre>
<p>表示请求 <code>paglet_id=&quot;pager&quot;</code> 的 widget，并把它渲染到页面的<code>&lt;div id=&quot;pager&quot;&gt;&lt;/div&gt;</code>
内。</p>
<p>这个接口提供了异步请求渲染一个 widget 的能力。这样就可以实现局刷了。</p>
<h4 class=""><a name="%E6%95%B4%E9%A1%B5%E5%88%87%E6%8D%A2" class="anchor" href="#%E6%95%B4%E9%A1%B5%E5%88%87%E6%8D%A2"><span class="octicon octicon-link"></span></a>整页切换</h4><p>支持整个页面的切换，例如：A 页面 -&gt; B 页面</p>
<pre><code>| A | B |
| {<span class="hljs-variable">%widget</span> name=<span class="hljs-string">"xxxx"</span> pagelet_id=<span class="hljs-string">"pager"</span><span class="hljs-variable">%}</span> | {<span class="hljs-variable">%widget</span> name=<span class="hljs-string">"oooo"</span> pagelet_id=<span class="hljs-string">"pager"</span><span class="hljs-variable">%}</span> |
</code></pre><p>两个都有相同的 pagelet_id 的 widget，整页切换。</p>
<p>提供 <code>widget_block</code> 来解决。只需要在 layout 里面使用 widget_block
其他页面 extends 即可。</p>
<pre><code class="hljs lang-smarty">{<span class="hljs-variable">%widget_block</span> pagelet_id=<span class="hljs-string">"pager"</span><span class="hljs-variable">%}</span>
    {<span class="hljs-variable">%block</span> name=<span class="hljs-string">"body"</span><span class="hljs-variable">%}</span>{<span class="hljs-variable">%/</span>block<span class="hljs-variable">%}</span>
{<span class="hljs-variable">%/</span>widget_block<span class="hljs-variable">%}</span>
</code></pre>
<p>整个页面就这样切换起来了。</p>
<h4 class=""><a name="%3Cstrong%3E%E9%A1%B5%E9%9D%A2%E7%AE%A1%E7%90%86%E5%BA%93page.js%3C/strong%3E" class="anchor" href="#%3Cstrong%3E%E9%A1%B5%E9%9D%A2%E7%AE%A1%E7%90%86%E5%BA%93page.js%3C/strong%3E"><span class="octicon octicon-link"></span></a><strong>页面管理库page.js</strong></h4><p>以上接口在使用时需要考虑前端很多细节，为此提供了 page.js 这个页面管路口库。</p>
<p>page.js 是跟 <a href="https://github.com/doith">@donny</a> 同学合作写的页面管理的前端库 <a href="https://github.com/xiangshouding/bigpipe.smarty/blob/master/single/common/static/lib/js/spljs/page.js">page.js</a></p>
<ul>
<li>事件代理，代理需要局刷的URL, 绑定异步接口;</li>
<li>前进后退控制， 使用pushState</li>
</ul>
<p>提供接口</p>
<h5 class=""><a name="appPage.start()" class="anchor" href="#appPage.start()"><span class="octicon octicon-link"></span></a>appPage.start()</h5><pre><code class="hljs lang-javascript">appPage.start(
    containerId: <span class="hljs-string">'pager'</span>,   <span class="hljs-comment">//pagelets渲染容器</span>
    pagelets: <span class="hljs-string">'pager'</span>,      <span class="hljs-comment">//请求的pagelet</span>
    validateUrl: <span class="hljs-regexp">/.*/i</span>,     <span class="hljs-comment">//符合这个规则的链接或者带data-href属性的元素进行事件代理</span>
    cacheMaxTime: <span class="hljs-number">1000</span>      <span class="hljs-comment">//每一个pagelet的缓存时间，视访问情况而定。</span>
);
</code></pre>
<h5 class=""><a name="data-area" class="anchor" href="#data-area"><span class="octicon octicon-link"></span></a>data-area</h5><p>如果更新小范围的内容该如何办？</p>
<ul>
<li>只需在触发元素上添加<code>data-area</code>属性，</li>
</ul>
<p>如;</p>
<pre><code class="hljs lang-html">&lt;<span class="hljs-literal">a</span> href=<span class="hljs-string">"/xxxxx"</span> data-area=<span class="hljs-string">"left-bar"</span>&gt;<span class="hljs-literal">A</span>&lt;/<span class="hljs-literal">a</span>&gt;
</code></pre>
<p>当点击时回请求页面的 <code>pagelet_id=&quot;left-bar&quot;</code> 的 widget，并渲染到当前页面的 <code>&lt;div id=&quot;left-bar&quot;&gt;&lt;/div&gt;</code> 内。</p>
<h5 class=""><a name="appPage.redirect()" class="anchor" href="#appPage.redirect()"><span class="octicon octicon-link"></span></a>appPage.redirect()</h5><pre><code class="hljs lang-javascript">appPage.redirect(
    <span class="hljs-string">"/index/page/index"</span>,
    {
        <span class="hljs-string">"pagelets"</span>: <span class="hljs-string">"test"</span>     <span class="hljs-comment">// 需要请求的pagelet</span>
        <span class="hljs-string">"containerId"</span>: <span class="hljs-string">"xxx"</span>   <span class="hljs-comment">// pagelet渲染的容器</span>
    }
);
</code></pre>
<p>如果还有一些小的 pagelet（widget）没有考虑到，可以用这个接口做加载。</p>
