<blockquote>
<p>高性能Webapp解决方案，利用后端渲染方式，实现传统webapp前端局刷效果，实现一站式的体验效果，大幅提高性能和静态资源缓存命中率。</p>
</blockquote>
<h3 class="" id="介绍"><a name="介绍" class="anchor" href="#介绍"><span class="doc-link"></span></a>介绍</h3><p>高性能Webapp解决方案，与传统webapp前端局刷（backbone等）相比，优势有：</p>
<ul>
<li>采用后端渲染，不使用前端模板，大幅提高渲染性能</li>
<li>几乎不改变开发习惯，轻松上手和改造原有项目。</li>
</ul>
<h3 class="" id="快速上手"><a name="快速上手" class="anchor" href="#快速上手"><span class="doc-link"></span></a>快速上手</h3><p>第一步，需要安装<a href="https://github.com/xiangshouding/bigpipe.smarty" title="BigPipe.smarty">fis-plus</a></p>
<blockquote>
<p>$ npm install -g fis-plus</p>
</blockquote>
<p>第二步，下载示例代码</p>
<p>linux or Unix:</p>
<blockquote>
<p>$ wget <a href="https://github.com/xiangshouding/bigpipe.smarty/archive/master.zip">https://github.com/xiangshouding/bigpipe.smarty/archive/master.zip</a></p>
</blockquote>
<p>windows:</p>
<p><a href="https://github.com/xiangshouding/bigpipe.smarty/archive/master.zip">下载</a></p>
<p>后解压，进入目录single</p>
<blockquote>
<p>$ cd bigpipe.smarty-master/single</p>
</blockquote>
<p>第三步，使用安装的<a href="https://github.com/xiangshouding/bigpipe.smarty" title="BigPipe.smarty">fis-plus</a>编译发布项目</p>
<blockquote>
<p>$ fisp release -cmpr common</p>
<p>$ fisp release -cmpr index</p>
</blockquote>
<p>第四步，启动开发服务器</p>
<blockquote>
<p>$ fisp server start</p>
</blockquote>
<p>第五步，安装本地测试框架</p>
<blockquote>
<p>$ fisp server install pc</p>
</blockquote>
<p>第六步，打开浏览器访问</p>
<p>局部刷新: <a href="">http://127.0.0.1:8080/index/page/index</a></p>
<h3 class="" id="使用文档"><a name="使用文档" class="anchor" href="#使用文档"><span class="doc-link"></span></a>使用文档</h3><h4 class=""><a name="<strong>引入插件</strong>" class="anchor" href="#<strong>引入插件</strong>"><span class="doc-link"></span></a><strong>引入插件</strong></h4><p>Webapp插件主要包括：</p>
<ul>
<li>后端解决方案插件 <a href="https://github.com/xiangshouding/fis-smarty-bigpipe-plugin" title="quickling plugin">Webapp解决方案的插件</a>。下载后放置到项目的plugin目录中。</li>
<li>前端加载器<a href="https://github.com/xiangshouding/bigpipe.smarty/blob/master/lazyrender/static/BigPipe.js" title="loader">loader</a>，<a href="https://github.com/xiangshouding/bigpipe.smarty/blob/master/lazyrender/static/BigPipe.js" title="loader">前端loader</a>依赖<a href="https://github.com/xiangshouding/bigpipe.smarty/blob/master/lazyrender/static/lazyload.js" title="lazyload.js">lazyload.js</a></li>
<li>FIS组件化库<a href="https://github.com/zjcqoo/mod" title="modjs">modjs</a>保持最新</li>
</ul>
<p>插件引入代码如下：</p>
<pre><code class="lang-smarty">{%html framework=&quot;common:static/lib/js/mod.js&quot;%}
    {%head%}
        ...
        {%require name=&quot;common:static/lib/js/lazyload.js&quot;%}
        {%require name=&quot;common:static/lib/js/BigPipe.js&quot;%}
        ...
    {%/head%}
    {%body%}
        ...
    {%/body%}
{%/html%}
</code></pre>
<p>最后，发布这个项目；访问对应URL查看页面。</p>
<h4 class=""><a name="<strong>支持localstorage</strong>" class="anchor" href="#<strong>支持localstorage</strong>"><span class="doc-link"></span></a><strong>支持localstorage</strong></h4><blockquote>
<p>无线端使用localstorage本地缓存，可以减少请求数目，提高性能。高性能Webapp解决方案也内置了localstorage本地缓存方案。</p>
</blockquote>
<p>只需要引入支持localstorage的FIS组件化库<a href="https://github.com/xiangshouding/mod-store.js" title="mod-store.js">mod-store.js</a>即可。</p>
<p>插件引入代码如下：</p>
<pre><code class="lang-smarty">{%html framework=&quot;common:static/lib/js/mod-store.js&quot;%}
    {%head%}
        ...
        {%require name=&quot;common:static/lib/js/lazyload.js&quot;%}
        {%require name=&quot;common:static/lib/js/BigPipe.js&quot;%}
        ...
    {%/head%}
    {%body%}
        ...
    {%/body%}
{%/html%}
</code></pre>
<h4 class=""><a name="<strong>前端loader</strong>" class="anchor" href="#<strong>前端loader</strong>"><span class="doc-link"></span></a><strong>前端loader</strong></h4><p><code>局部刷新</code> 中FIS提供了一个可被异步请求的<code>后端框架</code>(以<a href="https://github.com/xiangshouding/bigpipe.smarty" title="BigPipe.smarty">smarty插件</a>的方式)；
<a href="https://github.com/xiangshouding/bigpipe.smarty/blob/master/single/common/static/lib/js/BigPipe.js" title="loader">前端loader</a>。</p>
<p>前端loader提供接口<code>fetch</code>方法，来异步请求渲染一个widget。</p>
<pre><code class="lang-javascript">BigPipe.fetch(url, containerId);
</code></pre>
<p>例子</p>
<pre><code class="lang-javascript">BigPipe.fetch(&#39;/index/page/index?pagelets[]=&quot;pager&quot;&#39;, &#39;pager&#39;);
</code></pre>
<p>表示请求<code>paglet_id=&quot;pager&quot;</code>的widget，并把它渲染到页面的<code>&lt;div id=&quot;pager&quot;&gt;&lt;/div&gt;</code>
内。</p>
<p>这个接口提供了异步请求渲染一个widget的能力。这样就可以实现局刷了。</p>
<h4 class=""><a name="整页切换" class="anchor" href="#整页切换"><span class="doc-link"></span></a>整页切换</h4><p>支持整个页面的切换，例如：A页面 -&gt; B页面</p>
<pre><code>| A | B |
| {%widget name=&quot;xxxx&quot; pagelet_id=&quot;pager&quot;%} | {%widget name=&quot;oooo&quot; pagelet_id=&quot;pager&quot;%} |
</code></pre><p>两个都有相同的pagelet_id的widget，整页切换。</p>
<p>提供<code>widget_block</code>来解决。只需要在layout里面使用widget_block
其他页面extends即可。</p>
<pre><code class="lang-smarty">{%widget_block pagelet_id=&quot;pager&quot;%}
    {%block name=&quot;body&quot;%}{%/block%}
{%/widget_block%}
</code></pre>
<p>整个页面就这样切换起来了。</p>
<h4 class=""><a name="<strong>页面管理库page.js</strong>" class="anchor" href="#<strong>页面管理库page.js</strong>"><span class="doc-link"></span></a><strong>页面管理库page.js</strong></h4><p>以上接口在使用时需要考虑前端很多细节，为此提供了page.js这个页面管路口库。</p>
<p>page.js是跟<a href="https://github.com/doith">@donny</a> 同学合作写的页面管理的前端库<a href="https://github.com/xiangshouding/bigpipe.smarty/blob/master/single/common/static/lib/js/spljs/page.js">page.js</a></p>
<ul>
<li>事件代理，代理需要局刷的URL, 绑定异步接口;</li>
<li>前进后退控制， 使用pushState</li>
</ul>
<p>提供接口</p>
<h5 class=""><a name="appPage.start()" class="anchor" href="#appPage.start()"><span class="doc-link"></span></a>appPage.start()</h5><pre><code class="lang-javascript">appPage.start(
    containerId: &#39;pager&#39;,   //pagelets渲染容器
    pagelets: &#39;pager&#39;,      //请求的pagelet
    validateUrl: /.*/i,     //符合这个规则的链接或者带data-href属性的元素进行事件代理
    cacheMaxTime: 1000      //每一个pagelet的缓存时间，视访问情况而定。
);
</code></pre>
<h5 class=""><a name="data-area" class="anchor" href="#data-area"><span class="doc-link"></span></a>data-area</h5><p>如果更新小范围的内容该如何办？</p>
<ul>
<li>只需在触发元素上添加<code>data-area</code>属性，</li>
</ul>
<p>如;</p>
<pre><code class="lang-html">&lt;a href=&quot;/xxxxx&quot; data-area=&quot;left-bar&quot;&gt;A&lt;/a&gt;
</code></pre>
<p>当点击时回请求页面的<code>pagelet_id=&quot;left-bar&quot;</code>的widget，并渲染到当前页面的<code>&lt;div id=&quot;left-bar&quot;&gt;&lt;/div&gt;</code>内。</p>
<h5 class=""><a name="appPage.redirect()" class="anchor" href="#appPage.redirect()"><span class="doc-link"></span></a>appPage.redirect()</h5><pre><code class="lang-javascript">appPage.redirect(
    &quot;/index/page/index&quot;,
    {
        &quot;pagelets&quot;: &quot;test&quot;     // 需要请求的pagelet
        &quot;containerId&quot;: &quot;xxx&quot;   // pagelet渲染的容器
    }
);
</code></pre>
<p>如果还有一些小的pagelet（widget）没有考虑到，可以用这个接口做加载。</p>
