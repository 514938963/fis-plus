<h1 class="page-header"><a name="Quickling%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88" class="anchor" href="#Quickling%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="octicon octicon-link"></span></a>Quickling 解决方案</h1><blockquote>
<p>Quickling 适用于网络高延迟、低带宽场景的解决方案。</p>
</blockquote>
<ul>
<li>保证首屏及核心功能最快展现，使得展示核心功能所需要获取的数据、生成的 html 文档大小、资源加载量、渲染工作量最小化；</li>
<li>提高服务端的渲染效率和并行度，保证功能不会受到慢数据模块的影响；</li>
<li>支持 page cache 和用户缓存控制，可以避免大量的服务器端重复计算和客户端重复渲染</li>
</ul>
<h3 class="" id="背景"><a name="%E8%83%8C%E6%99%AF" class="anchor" href="#%E8%83%8C%E6%99%AF"><span class="octicon octicon-link"></span></a>背景</h3><blockquote>
<p><strong>Quickling</strong> 这个词诞生自 <a href="http://www.slideshare.net/ajaxexperience2009/chanhao-jiang-and-david-wei-presentation-quickling-pagecache">facebook Web 优化方案</a>，它指的是页面的某一个块可以通过 Ajax 请求，包括这块使用到的静态资源，然后通过 JSON 方式返回给前端加载器，前端加载器先加载静态资源然后渲染块，这样得到一个可展示的页面局部，可以把它放到当前页的任何地方。</p>
</blockquote>
<p><strong>Quickling 解决方案 </strong> 也使用相同的原理。得益于 FIS 2.0，我们很轻松就可以搞定整个逻辑的实现。</p>
<h3 class="" id="解决方案特性"><a name="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E7%89%B9%E6%80%A7" class="anchor" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E7%89%B9%E6%80%A7"><span class="octicon octicon-link"></span></a>解决方案特性</h3><blockquote>
<p>介绍 Quickling 是如何工作。解决方案特性：</p>
</blockquote>
<ul>
<li><strong>A</strong> 支持任意一个 widget 被异步请求，请求内容包括渲染好的 HTML 及静态资源</li>
<li><strong>B</strong> 当 widget 指定为异步请求时，渲染引用此 widget 模版时不会渲染此 widget，降低后端渲染模版压力。</li>
</ul>
<h3 class="" id="使用场景"><a name="%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF" class="anchor" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="octicon octicon-link"></span></a>使用场景</h3><p>使用场景一栏，主要给大家展示一些案例，来引导理解整个解决方案。</p>
<h4 class=""><a name="%E6%A1%88%E4%BE%8B%E4%B8%80" class="anchor" href="#%E6%A1%88%E4%BE%8B%E4%B8%80"><span class="octicon octicon-link"></span></a>案例一</h4><p>项目 A 中使用方案提供的最初使用前端模板实现 webapp 一站式效果，但是前端渲染的形式，在展示的时候后端获取数据分为两步，展现页面时只能等数据拿到以后才能进行展现，而恰巧获取数据时比较慢，导致页面出现卡顿。那么我们用 <strong>Quickling 解决方案 </strong> 如何解决这个问题呢？</p>
<p>答案很简单，展现页面的时候也分为两步走，第一次渲染的时候拿到比较重要那块的数据，并渲染对应的部分页面。再发起一次异步请求，请求剩下的部分页面。这样至少用户不会感觉到卡顿。是不是看着似曾相识，这个就好比纯的 WebApp 在渲染一个页面时，请求两次数据并渲染页面一样。但这个是后端模板层面支持的。</p>
<h4 class=""><a name="%E6%A1%88%E4%BE%8B%E4%BA%8C" class="anchor" href="#%E6%A1%88%E4%BE%8B%E4%BA%8C"><span class="octicon octicon-link"></span></a>案例二</h4><p>项目 B 主要服务于东南亚地区，这些国家的网络有个特点，那就是 <strong> 慢 </strong>，有 IPHONE 并使用移动号的同学拿出手机访问一下某网站试试，就那种感觉。通过项目 B 同学的反馈以及统计数据显示，下载 HTML 的速度都慢的可怜。还有一个问题并发时下载资源之间抢带宽，阻塞页面的渲染。</p>
<h4 class=""><a name="%E9%97%AE%E9%A2%98" class="anchor" href="#%E9%97%AE%E9%A2%98"><span class="octicon octicon-link"></span></a>问题</h4><blockquote>
<p>总结一下俩问题上面两个案例的问题</p>
</blockquote>
<ul>
<li>html 太大，导致下载太慢</li>
<li>资源抢带宽，阻塞页面渲染</li>
</ul>
<p>那通过 <strong>Quickling 解决方案 </strong> 如何解决问题呢。可以通过，</p>
<ul>
<li>整个页面多次渲染，第一次访问或者刷新时只渲染首屏，这样展示首屏的时候就减少了很多 html。下载变快了</li>
<li>拆分逻辑，把基础功能的 css 内联，增强功能的 css 在一定条件下触发请求，js 进行异步加载。这样控制后页面渲染就变快了。</li>
</ul>
<h4 class=""><a name="%E6%80%BB%E7%BB%93" class="anchor" href="#%E6%80%BB%E7%BB%93"><span class="octicon octicon-link"></span></a>总结</h4><p><strong> 案例一 </strong> 和 <strong> 案例二 </strong> 中可以看到，Quickling 解决方案很好的解决了这些遇到的问题，而案例中说到的情况就是方案已知的适用场景，其他场景还有待发现。</p>
<h3 class="" id="使用方法"><a name="%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95" class="anchor" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="octicon octicon-link"></span></a>使用方法</h3><blockquote>
<p>很多同学到这里就有疑问了，如此复杂的请求方式，一个页面可以分块请求，是不是需要在开发的时候实现很多东西，维护起来很麻烦。答案是 <strong> 否定 </strong> 的。整个方案依托于 FIS 2.0 的前端架构思想，从目录结构到静态资源管理。只需要做很小的工作就瞬间享受到 <strong>Quickling 解决方案 </strong> 带来的新特性。</p>
</blockquote>
<p>首先得有一个后端模板是 Smarty 的项目，并且是使用 FIS 制定的目录规范以及用 FIS 编译。目录结构是这样的；</p>
<pre><code class="hljs lang-bash">├── build<span class="hljs-class">.sh</span>
├── config
├── fis-conf<span class="hljs-class">.js</span>
├── page
├── static
├── test
└── widget
</code></pre>
<p>每个目录放些什么，就不一一说明了，见 <a href="http://fe.baidu.com/doc/fis/2.0/user/">FIS2.0 文档</a>。我们只关注 <strong>widget</strong> 和 <strong>page</strong> 。</p>
<p>假设有一个 widget <strong>widget_A</strong> ，包括一个模板文件 widget_A.tpl 和一个 js 文件 widget_A.js 还有一个 css 文件 widget_A.css。有个页面 <strong>index.tpl</strong> 要使用这个 widget。</p>
<pre><code class="hljs lang-bash">├── page
│   └── index<span class="hljs-class">.tpl</span>
└── widget
    └── widget_A
        ├── widget_A<span class="hljs-class">.js</span>
        ├── widget_A<span class="hljs-class">.css</span>
        └── widget_A.tpl
</code></pre>
<p>网站展示时渲染 <strong>index.tpl</strong> ，widget_A 是页面中的一部分。</p>
<pre><code class="hljs lang-html"><span class="hljs-comment">//index.tpl</span>
{<span class="hljs-variable">%widget</span> name=<span class="hljs-string">"demo:widget/widget_A/widget_A.tpl"</span><span class="hljs-variable">%}</span>
</code></pre>
<p>当页面被渲染时，widget_A 就展现在页面上了。</p>
<pre><code class="hljs lang-html">&lt;html&gt;
<span class="hljs-keyword">...</span>
    &lt;link href=<span class="hljs-string">"widget_A.css"</span> rel=<span class="hljs-string">"stylesheet"</span> type=<span class="hljs-string">"text/css"</span> /&gt;
....
    &lt;div&gt; 我是 widget_A &lt;/div&gt;
....
    &lt;script src=<span class="hljs-string">"widget_A.js"</span> type=<span class="hljs-string">"text/javascript"</span>&gt;&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<p>上面是正常的使用方式，就像 <strong> 方案二 </strong> 中说到的，如何让渲染 index.tpl 时不展示 <strong>widget_A</strong> 呢。</p>
<pre><code class="hljs lang-html">{%widget <span class="hljs-variable">name=</span><span class="hljs-string">"demo:widget/widget_A/widget_A.tpl"</span> <span class="hljs-variable">mode=</span><span class="hljs-string">"quickling"</span> <span class="hljs-variable">pagelet_id=</span><span class="hljs-string">"widget_A"</span>%}
</code></pre>
<p>OK，改造完成。
加了 <code>mode=&quot;quickling&quot;</code> 和 <code>pagelet_id=&quot;widget_A&quot;</code> 这俩参数。
这时候渲染页面的结果是什么呢？</p>
<pre><code class="hljs lang-html">&lt;html&gt;
.....
&lt;<span class="hljs-tag">textarea</span> class=<span class="hljs-string">"fis_g_bigrender"</span> style=“<span class="hljs-attribute">display</span>:<span class="hljs-attribute">none</span>”&gt;BigPipe.<span class="hljs-function"><span class="hljs-title">asyncLoad</span><span class="hljs-params">({id: <span class="hljs-string">"widget_A"</span>})</span></span>&lt;/textarea&gt;
&lt;<span class="hljs-tag">div</span> id=<span class="hljs-string">"widget_A"</span>&gt;&lt;/div&gt;
.....
&lt;/html&gt;
</code></pre>
<p>如上代码，做了俩事情。</p>
<ol>
<li>挖了个坑 <code>&lt;div id=&quot;widget_A&quot;&gt;&lt;/div&gt;</code>，异步请求回来的 widget_A 的 html 就放在这个坑了。</li>
<li>在 textarea 里面打了一个 JS 函数，这个思路来自 bigrender，可以在页面滚动到那个部位才去拉取数据。</li>
</ol>
<p>等页面渲染完后，开发的同学需要做什么，他只需要把 textarea 里面的代码根据自己的需求执行就成，比如滚轮滚那个地方，domready 后。。。这个自己决定。</p>
<p>说到这里我想你也知道如何使用了。</p>
<p><strong> 使用步骤 </strong> ：</p>
<ul>
<li>widget 调用的时候设定这个 widget 的 <strong> 渲染模式 </strong> 为 <code>quickling</code>，<code>mode=&quot;quickling&quot;</code></li>
<li>widget 调用的时候设定 pagelet_id, <code>pagelet_id=&quot;widget_A&quot;</code></li>
<li>运行时，取出 class=&quot;fis_g_bigrender&quot; 中包含的代码，运行它</li>
<li>页面引入前端加载器 <a href="https://github.com/xiangshouding/bigpipe.smarty">BigPipe.js</a></li>
<li>项目中使用方案提供的 <a href="https://github.com/xiangshouding/fis-smarty-bigpipe-plugin">smarty 插件</a></li>
</ul>
<p><strong> 相关资源 </strong> ：</p>
<ul>
<li><a href="https://github.com/xiangshouding/bigpipe.smarty">demo</a></li>
<li><a href="https://github.com/xiangshouding/fis-smarty-bigpipe-plugin">Smarty 插件</a></li>
</ul>
<h3 class="" id="优点和缺点"><a name="%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9" class="anchor" href="#%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9"><span class="octicon octicon-link"></span></a>优点和缺点</h3><p>有了使用场景而且也知道如何使用，那现在开始总结一下它到底有哪些优点，事物都是双面的当然也有缺点。这栏总结一下整个方案的优缺点。按照一贯的做法，先说优点。</p>
<h4 class=""><a name="%E4%BC%98%E7%82%B9" class="anchor" href="#%E4%BC%98%E7%82%B9"><span class="octicon octicon-link"></span></a>优点</h4><ul>
<li><strong> 灵活 </strong> 页面 widget 可以灵活请求</li>
<li><strong> 可维护性高 </strong> FIS 用户项目都是组件化的，维护肯定是最好的</li>
<li><strong> 使用简单 </strong> 只需要关注那些页面部分想后展示、具体展示的时机</li>
<li><strong> 能解决特定问题 </strong>  案例一和案例二已经说明了这一点。</li>
</ul>
<h4 class=""><a name="%E7%BC%BA%E7%82%B9" class="anchor" href="#%E7%BC%BA%E7%82%B9"><span class="octicon octicon-link"></span></a>缺点</h4><ul>
<li>增加了请求  一个页面渲染，如果某一个 widget 显然模式是“quickling”，那么渲染页面就会多一次请求</li>
<li>增加了服务器负担</li>
</ul>
<p><strong> 性能本来就是一个折中，方案有优缺点，就看具体场景需要了。</strong></p>
