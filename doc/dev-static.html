<h3 class="" id="JS &amp; CSS"><a name="JS%20&amp;%20CSS" href="#JS%20&amp;%20CSS">JS &amp; CSS</a></h3><h4 class=""><a name="JS%E7%BB%84%E4%BB%B6%E5%8C%96" href="#JS%E7%BB%84%E4%BB%B6%E5%8C%96">JS组件化</a></h4><div class="bs-callout bs-callout-info">
&gt; 在前端开发中，JS资源占了很大一部分比例，在FIS中，我们将JS资源分为组件和非组件类。组件类JS资源可以通过前端组件化框架进行资源加载，同时会进行组件化包装。非组件类JS资源，用户可以通过同步script标签加载方式或通过require插件方式加载。
</div>

<p>在 <strong> 模块根目录 /widget/</strong> 下的 JS 资源皆为组件化资源，可以通过 require 和 require.async 进行调用，则在编译处理过程中会进行组件化封装。</p>
<h5 class=""><a name="modjs%E5%89%8D%E7%AB%AF%E7%BB%84%E4%BB%B6%E5%8C%96%E6%A1%86%E6%9E%B6" href="#modjs%E5%89%8D%E7%AB%AF%E7%BB%84%E4%BB%B6%E5%8C%96%E6%A1%86%E6%9E%B6">modjs前端组件化框架</a></h5><p>modJS 是一套的前端模块加载解决方案。与传统的模块加载相比，modJS 会根据产品实际使用场景，自动选择一种相应的方案，使最终的实现非常轻量简洁。
作为 FIS 前端组件化框架，完全遵循 AMD 规范，用户可以通过 lights 进行安装</p>
<pre><code>lights <span class="hljs-keyword">install</span> modjs
</code></pre><p>同时在开发中需要使用 modjs, 则需要通过 <a href="#html"> 模板插件语法 html</a>进行注册。</p>
<h5 class=""><a name="%E7%BB%84%E4%BB%B6%E5%8C%96%E5%B0%81%E8%A3%85" href="#%E7%BB%84%E4%BB%B6%E5%8C%96%E5%B0%81%E8%A3%85">组件化封装</a></h5><p>modjs 使用 define 来定义一个模块：</p>
<pre><code class="hljs lang-javascript"><span class="hljs-class"><span class="hljs-keyword">define</span> </span>(id, factory)
</code></pre>
<p><code> 在平常开发中，我们只需写 factory 中的代码即可，无需手动定义模块 </code>。发布工具会自动将模块代码嵌入 factory 的闭包里。</p>
<p>factory 提供了 3 个参数：require, exports, module ，用于模块的引用和导出。</p>
<p>在编译处理过程中会对 JS 文件进行组件化 define 包装处理:</p>
<ul>
<li>JS源码：</li>
</ul>
<pre><code class="hljs lang-javascript"><span class="hljs-comment">//common/widget/menu/menu.js</span>
<span class="hljs-keyword">var</span> $ = <span class="hljs-built_in">require</span>(<span class="hljs-string">'common:widget/jquery/jquery.js'</span>);

exports.init = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    $(<span class="hljs-string">'.menu-ui ul li a'</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(event)</span> </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
        $(<span class="hljs-string">'.menu-ui ul li a.active'</span>).removeClass(<span class="hljs-string">'active'</span>);
        $(self).addClass(<span class="hljs-string">'active'</span>);
        event.preventDefault();
    });
};
</code></pre>
<ul>
<li>编译后代码：</li>
</ul>
<pre><code class="hljs lang-javascript">define(<span class="hljs-string">'common:widget/menu/menu.js'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(require, exports, module)</span></span>{
    <span class="hljs-keyword">var</span> $ = <span class="hljs-built_in">require</span>(<span class="hljs-string">'common:widget/jquery/jquery.js'</span>);
    exports.init = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
        $(<span class="hljs-string">'.menu-ui ul li a'</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(event)</span> </span>{
            <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
            $(<span class="hljs-string">'.menu-ui ul li a.active'</span>).removeClass(<span class="hljs-string">'active'</span>);
            $(self).addClass(<span class="hljs-string">'active'</span>);
            event.preventDefault();
        });
    };
});
</code></pre>
<h5 class=""><a name="%E7%BB%84%E4%BB%B6%E5%8C%96%E8%B0%83%E7%94%A8" href="#%E7%BB%84%E4%BB%B6%E5%8C%96%E8%B0%83%E7%94%A8">组件化调用</a></h5><ul>
<li><p>modJS 的发布工具会保证你的程序在使用之前，所有依赖的模块都已加载。因此当我们需要一个模块时，只需提供一个模块名即可获取：</p>
<p><strong>require</strong> (id)</p>
<pre><code class="hljs lang-javascript">  <span class="hljs-comment">//id可为相对路径，或FIS中组件调用路径 模块名:文件所在widget中路径</span>
  <span class="hljs-function"><span class="hljs-title">require</span><span class="hljs-params">(<span class="hljs-string">"common:widget/ui/a/a.js"</span>)</span></span>
</code></pre>
</li>
</ul>
<p> 因为所需的模块都已预先加载，因此 require 可以立即返回该模块。</p>
<ul>
<li><p>考虑到有些模块无需在启动时载入，因此 modJS 提供了可以在运行时 <code> 异步加载模块的接口</code>：</p>
<p><strong>require.async</strong> (names, callback)</p>
<p>names 可以是一个 id，或者是数组形式的 id 列表。</p>
<p>当所有都加载都完成时，callback 被调用，names 对应的模块实例将依次传入。</p>
<p>使用 require.async 获取的模块不会被发布工具安排在预加载中，因此在完成回调之前 require 将会抛出模块未定义错误。</p>
<pre><code class="hljs lang-javascript">  <span class="hljs-comment">//id可为相对路径，或FIS-Plus中组件调用路径 模块名:文件所在widget中路径</span>
  <span class="hljs-built_in">require</span>.async([<span class="hljs-string">"common:widget/menu/menu.js"</span>],<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(menu)</span></span>{
        menu.init()
  })
</code></pre>
</li>
<li><p><a href="/userdoc/fis/modjs"> 了解更多 modjs</a></p>
</li>
</ul>
<h5 class=""><a name="%E5%85%B6%E4%BB%96JS" href="#%E5%85%B6%E4%BB%96JS">其他JS</a></h5><p>在非 widget 目录下的 JS 资源，皆为非组件化资源。用户可以通过 script 标签、<a href="#require">require 插件 </a> 等方式进行调用.</p>
<h5 class=""><a name="%E6%A8%A1%E6%9D%BF%E7%BB%84%E4%BB%B6%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90" href="#%E6%A8%A1%E6%9D%BF%E7%BB%84%E4%BB%B6%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90">模板组件静态资源</a></h5><p>与模板组件同名的静态资源，FIS 会自动添加依赖关系，同时会对 JS、CSS 进行同步加载。</p>
<pre><code class="hljs lang-bash">tpl ：模板根目录/widget/widgetName/widgetName<span class="hljs-class">.tpl</span>
js ：模板根目录/widget/widgetName/widgetName<span class="hljs-class">.js</span>
css ：模板根目录/widget/widgetName/widgetName.css
</code></pre>
<h4 class=""><a name="CSS%E7%BB%84%E4%BB%B6%E5%8C%96" href="#CSS%E7%BB%84%E4%BB%B6%E5%8C%96">CSS组件化</a></h4><blockquote>
<p>在前端开发中，CSS 资源占了很大一部分比例，在 FIS 中，我们将 CSS 资源分为组件和非组件类。CSS 组件会绑定到同名 JS 组件、模板组件上，进行加载管理，用户不需要关心加载方式；非组件类 CSS 资源通过 link 标签、require 插件方式进行加载。</p>
</blockquote>
<p>在 <strong> 模块根目录 /widget</strong> 目录下的 CSS 资源，皆为组件。在模板组件中以及 JS 组件中对应同名的 CSS 组件会自动与模板组件、JS 组件添加依赖关系，进行加载管理，用户不需要显示进行调用加载。</p>
<h5 class=""><a name="%E5%85%B6%E4%BB%96CSS" href="#%E5%85%B6%E4%BB%96CSS">其他CSS</a></h5><p>在非 widget 目录下的 CSS 资源，皆为非组件化资源。用户可以通过 link 标签、<a href="#require">require 插件 </a> 等方式进行调用.</p>
<h5 class=""><a name="%E6%A8%A1%E6%9D%BF%E7%BB%84%E4%BB%B6%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90" href="#%E6%A8%A1%E6%9D%BF%E7%BB%84%E4%BB%B6%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90">模板组件静态资源</a></h5><p><code> 与模板组件同名的静态资源，FIS 会自动添加依赖关系，同时会对 JS、CSS 进行同步加载 </code>。</p>
<pre><code class="hljs lang-bash">tpl ：模板根目录/widget/widgetName/widgetName<span class="hljs-class">.tpl</span>
js ：模板根目录/widget/widgetName/widgetName<span class="hljs-class">.js</span>
css ：模板根目录/widget/widgetName/widgetName.css
</code></pre>
<h5 class=""><a name="Less%E8%B5%84%E6%BA%90" href="#Less%E8%B5%84%E6%BA%90">Less资源</a></h5><p>在 FIS 中默认配置了对 less 资源处理插件，less 文件编译处理后变为 css 文件。</p>
